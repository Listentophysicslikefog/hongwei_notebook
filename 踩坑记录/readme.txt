解决问题的记录


shell编程链接 : https://ftp.sjtu.edu.cn/Linux-HOWTO/LDP/abs/html/abs-guide.html

好了，关于链表的知识我们就讲完了。我们现在回过头来看下开篇留给你的思考题。如何基于链表
实现LRU缓存淘汰算法？
我的思路是这样的：我们维护⼀个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有⼀
个新的数据被访问时，我们从链表头开始顺序遍历链表。
1.如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位
置删除，然后再插⼊到链表的头部。
2.如果此数据没有在缓存链表中，⼜可以分为两种情况：
如果此时缓存未满，则将此结点直接插⼊到链表的头部；
如果此时缓存已满，则链表尾结点删除，将新的数据结点插⼊链表的头部。
这样我们就⽤链表实现了⼀个LRU缓存，是不是很简单？
现在我们来看下m缓存访问的时间复杂度是多少。因为不管缓存有没有满，我们都需要遍历⼀遍链
表，所以这种基于链表的实现思路，缓存访问的时间复杂度为O(n)。
实际上，我们可以继续优化这个实现思路，⽐如引⼊散列表（Hash table）来记录每个数据的位
置，将缓存访问的时间复杂度降到O(1)。因为要涉及我们还没有讲到的数据结构，所以这个优化⽅
案，我现在就不详细说了，等讲到散列表的时候，我会再拿出来讲。
除了基于链表的实现思路，实际上还可以⽤数组来实现LRU缓存淘汰策略。如何利⽤数组实现LRU
缓存淘汰策略呢？我把这个问题留给你思考。
