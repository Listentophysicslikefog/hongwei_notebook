1.对象的定义
－像结构体一样定义和使用对象及其公开的成员
－私有成员不可在对象外部直接访问

2. 对象构造

对象构造的意义
－构造就是初始化，在定义对象时初始化其数据成员
对象构造的技术手段：使用构造函数
－与类类型同名，没有返回值类型（包括void类型）
－构造函数允许重载
－构造函数可以带缺省参数，但是不建议，如果自带缺省参数那么代码阅读性不好
－至少公开一个构造函数，外界构造对象时需要构造函数
－只能由系统在创建对象时自动调用，程序其他部分不能直接调用

//例子

设计表示二维平面上圆的类类型

/*  圆类库接口“circle.h”*/

class Circle
{
public:
  Circle();
  //Circle( double r, double x = 0.0, double y = 0.0 );    // 缺省参数，不建议，缺省参数只可以从后边挨着开始缺省，不可以跳着缺省
  Circle( double r, double x, double y );
  ……
private:
  double r, x, y;
};

3.  缺省构造函数
https://blog.csdn.net/qq_43573743/article/details/104855508

类没有明确的构造函数
－系统自动产生一个缺省构造函数，自动调用
－缺省构造函数无参数，且函数体中没有任何语句
－如果定义了任意一个构造函数，则不再生成缺省构造函数

缺省构造函数调用示例
－正确示例：Circle circle;  //这个会自动调用缺省构造函数
－错误示例：Circle circle();  
－在构造函数无参数时，不能使用函数形式构造对象。原因？
答案：
  当我们没有定义构造函数时，系统会自动调用一个无参无函数体的构造函数。但是如果定义了一个构造函数，无论是什么样的，系统的构造函数便不再被使用。
也就是说，当我们定义了一个带参数的构造函数，但是没有定义无参的构造函数，在生成对象时，如果想使用无参构造函数进行实例化，便会报错。只能使用我们定义过的构造函数实例化。因此，在一个类中，保险起见，构造函数至少定义两个，包含一个无参数的。

4. 拷贝构造函数

拷贝构造函数用于构造已有对象的副本，就是将已有对象的值一个一个的复制过去
拷贝构造函数单参数，为本类的常对象的引用
如未定义，系统自动产生一个缺省拷贝构造函数
缺省拷贝构造函数为位拷贝（浅拷贝，对于指针的时候只可以拷贝指针的值，不可以完成指针指向的对象的拷贝），如需完成指针所指向的数据对象的拷贝就需要深拷贝（例如成员为指针，自己声明空间去存储指针指向对象的值），需自行定义


//下面是浅拷贝
/*  圆类库接口“circle.h”*/
class Circle
{
public:
  Circle( const Circle & that );
  ……
private:
  double r, x, y;
};


/*  圆类库实现“circle.cpp”*/
Circle::Circle( const Circle & that )
{
  this->r = that.r;
  this->x = that.x;
  this->y = that.y;
};


5. 构造函数初始化列表


class A
{
public:
  A( int a );
private:
  int a;
};

class B
{
public:
  B( int a, int b );
private:
  A a;
  int b;
};


//初始化列表 ，用构造的时候传入的参数去初始化类的成员变量
A::A( int a ) : a(a)
{
}

B::B( int a, int b ) : a(a), b(b)
{
}

初始化列表的目的与意义
－初始化列表是在构造对象时，同步构造内部对象(就是在构造对象的瞬间初始化对象参数)，如果写在构造函数里面那么初始化参数会在对象在构造完成后进行初始化调用的。
－部分成员（常量与引用）只能初始化，不能赋值，比如const常数，这样可以通过初始化列表初始化
－部分成员（类的对象）如果赋值，将导致两次构造（在初始化列表构造可以解决该问题），构造对象的时候，如果这个对象(称为A)的一个数据成员是另外一个类的对象(称为B)，那么构造对象A的时候就分配整个对象A的存储空间然后进行初始化，没有把类B的对象在初始化列表写出来的时候那么就会缺省的构造这个对象B，然后执行构造函数的函数体会发现里面还要构造一次对象B。所以B就构造两次了。
·　在分配内存时，调用缺省构造函数构造，然后执行构造函数体内
　 的赋值语句再次构造，效率不佳
·　若类没有缺省构造函数，则会导致问题
注意事项
－成员初始化按照成员定义顺序，而不是初始化列表顺序
－必须保持初始化列表和成员定义的顺序一致性，但允许跳过部分
　成员；否则后续成员可能不会正确初始化

6. 对象的析构

对象析构的意义
－析构就是终止化，在对象生命期结束时清除它
对象析构的技术手段：使用析构函数
－与类类型同名，前有“~”记号，无返回值类型（包括void类
　型），无参数
－析构函数必须是公开的
－可以由系统在销毁对象时自动调用，也可以由程序其他部分直接
　调用，但两者工作原理不同
－每个类只能有一个析构函数
－若未定义，系统会自动产生一个缺省析构函数，该函数无代码


定义析构函数的目的
－用于释放对象中动态分配内存的目标数据对象

使用示例
　class A{
　public:
 　 A( int x );
　  ~A();
　private:
　  int * p;
　};

A::A( int x )
{
  p = new int;
  *p = x;
}
A::~A()
{
  delete p,  p = NULL;
}//delete p 销毁指针指向的内存对象

6. 对象数组

对象数组
－像普通数组一样定义和使用

对象数组的初始化
－当构造函数单参数时，像普通数组一样构造所有元素
－当构造函数多参数时，使用下述方法构造
Circle circles[2] = { Circle(1.0, 0.0, 0.0), Circle(2.0, 1.0, 1.0) };